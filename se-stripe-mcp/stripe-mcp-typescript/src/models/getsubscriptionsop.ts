/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { ClosedEnum } from "../types/enums.js";
import { ErrorT, ErrorT$zodSchema } from "./error.js";
import { Subscription, Subscription$zodSchema } from "./subscription.js";

/**
 * Filter subscriptions by their automatic tax settings.
 */
export type AutomaticTaxFilterParams = { enabled: boolean };

export const AutomaticTaxFilterParams$zodSchema: z.ZodType<
  AutomaticTaxFilterParams
> = z.object({
  enabled: z.boolean(),
}).describe("Filter subscriptions by their automatic tax settings.");

/**
 * The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`.
 */
export const GetSubscriptionsCollectionMethod = {
  ChargeAutomatically: "charge_automatically",
  SendInvoice: "send_invoice",
} as const;
/**
 * The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`.
 */
export type GetSubscriptionsCollectionMethod = ClosedEnum<
  typeof GetSubscriptionsCollectionMethod
>;

export const GetSubscriptionsCollectionMethod$zodSchema = z.enum([
  "charge_automatically",
  "send_invoice",
]).describe(
  "The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`.",
);

export type GetSubscriptionsCreatedRangeQuerySpecs = {
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export const GetSubscriptionsCreatedRangeQuerySpecs$zodSchema: z.ZodType<
  GetSubscriptionsCreatedRangeQuerySpecs
> = z.object({
  gt: z.int().optional(),
  gte: z.int().optional(),
  lt: z.int().optional(),
  lte: z.int().optional(),
});

/**
 * Only return subscriptions that were created during the given date interval.
 */
export type GetSubscriptionsCreated =
  | GetSubscriptionsCreatedRangeQuerySpecs
  | number;

export const GetSubscriptionsCreated$zodSchema: z.ZodType<
  GetSubscriptionsCreated
> = z.union([
  z.lazy(() => GetSubscriptionsCreatedRangeQuerySpecs$zodSchema),
  z.int(),
]).describe(
  "Only return subscriptions that were created during the given date interval.",
);

export type CurrentPeriodEndRangeQuerySpecs = {
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export const CurrentPeriodEndRangeQuerySpecs$zodSchema: z.ZodType<
  CurrentPeriodEndRangeQuerySpecs
> = z.object({
  gt: z.int().optional(),
  gte: z.int().optional(),
  lt: z.int().optional(),
  lte: z.int().optional(),
});

/**
 * Only return subscriptions whose minimum item current_period_end falls within the given date interval.
 */
export type CurrentPeriodEnd = CurrentPeriodEndRangeQuerySpecs | number;

export const CurrentPeriodEnd$zodSchema: z.ZodType<CurrentPeriodEnd> = z.union([
  z.lazy(() => CurrentPeriodEndRangeQuerySpecs$zodSchema),
  z.int(),
]).describe(
  "Only return subscriptions whose minimum item current_period_end falls within the given date interval.",
);

export type CurrentPeriodStartRangeQuerySpecs = {
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export const CurrentPeriodStartRangeQuerySpecs$zodSchema: z.ZodType<
  CurrentPeriodStartRangeQuerySpecs
> = z.object({
  gt: z.int().optional(),
  gte: z.int().optional(),
  lt: z.int().optional(),
  lte: z.int().optional(),
});

/**
 * Only return subscriptions whose maximum item current_period_start falls within the given date interval.
 */
export type CurrentPeriodStart = CurrentPeriodStartRangeQuerySpecs | number;

export const CurrentPeriodStart$zodSchema: z.ZodType<CurrentPeriodStart> = z
  .union([
    z.lazy(() => CurrentPeriodStartRangeQuerySpecs$zodSchema),
    z.int(),
  ]).describe(
    "Only return subscriptions whose maximum item current_period_start falls within the given date interval.",
  );

/**
 * The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://docs.stripe.com/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.
 */
export const GetSubscriptionsStatus = {
  Active: "active",
  All: "all",
  Canceled: "canceled",
  Ended: "ended",
  Incomplete: "incomplete",
  IncompleteExpired: "incomplete_expired",
  PastDue: "past_due",
  Paused: "paused",
  Trialing: "trialing",
  Unpaid: "unpaid",
} as const;
/**
 * The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://docs.stripe.com/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.
 */
export type GetSubscriptionsStatus = ClosedEnum<typeof GetSubscriptionsStatus>;

export const GetSubscriptionsStatus$zodSchema = z.enum([
  "active",
  "all",
  "canceled",
  "ended",
  "incomplete",
  "incomplete_expired",
  "past_due",
  "paused",
  "trialing",
  "unpaid",
]).describe(
  "The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://docs.stripe.com/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.",
);

export type GetSubscriptionsRequest = {
  automatic_tax?: AutomaticTaxFilterParams | undefined;
  collection_method?: GetSubscriptionsCollectionMethod | undefined;
  created?: GetSubscriptionsCreatedRangeQuerySpecs | number | undefined;
  current_period_end?: CurrentPeriodEndRangeQuerySpecs | number | undefined;
  current_period_start?: CurrentPeriodStartRangeQuerySpecs | number | undefined;
  customer?: string | undefined;
  customer_account?: string | undefined;
  ending_before?: string | undefined;
  expand?: Array<string> | undefined;
  limit?: number | undefined;
  price?: string | undefined;
  starting_after?: string | undefined;
  status?: GetSubscriptionsStatus | undefined;
  test_clock?: string | undefined;
};

export const GetSubscriptionsRequest$zodSchema: z.ZodType<
  GetSubscriptionsRequest
> = z.object({
  automatic_tax: z.lazy(() => AutomaticTaxFilterParams$zodSchema).optional(),
  collection_method: GetSubscriptionsCollectionMethod$zodSchema.optional(),
  created: z.union([
    z.lazy(() => GetSubscriptionsCreatedRangeQuerySpecs$zodSchema),
    z.int(),
  ]).optional(),
  current_period_end: z.union([
    z.lazy(() => CurrentPeriodEndRangeQuerySpecs$zodSchema),
    z.int(),
  ]).optional(),
  current_period_start: z.union([
    z.lazy(() => CurrentPeriodStartRangeQuerySpecs$zodSchema),
    z.int(),
  ]).optional(),
  customer: z.string().describe(
    "The ID of the customer whose subscriptions you're retrieving.",
  ).optional(),
  customer_account: z.string().describe(
    "The ID of the account representing the customer whose subscriptions you're retrieving.",
  ).optional(),
  ending_before: z.string().describe(
    "A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.",
  ).optional(),
  expand: z.array(z.string()).describe(
    "Specifies which fields in the response should be expanded.",
  ).optional(),
  limit: z.int().describe(
    "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.",
  ).optional(),
  price: z.string().describe(
    "Filter for subscriptions that contain this recurring price ID.",
  ).optional(),
  starting_after: z.string().describe(
    "A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.",
  ).optional(),
  status: GetSubscriptionsStatus$zodSchema.optional(),
  test_clock: z.string().describe(
    "Filter for subscriptions that are associated with the specified test clock. The response will not include subscriptions with test clocks if this and the customer parameter is not set.",
  ).optional(),
});

/**
 * Successful response.
 */
export type SubscriptionsSubscriptionList = {
  data: Array<Subscription>;
  has_more: boolean;
  url: string;
};

export const SubscriptionsSubscriptionList$zodSchema: z.ZodType<
  SubscriptionsSubscriptionList
> = z.object({
  data: z.array(Subscription$zodSchema),
  has_more: z.boolean(),
  url: z.string(),
}).describe("Successful response.");

export type GetSubscriptionsResponse = {
  ContentType: string;
  StatusCode: number;
  RawResponse: Response;
  SubscriptionsSubscriptionList?: SubscriptionsSubscriptionList | undefined;
  error?: ErrorT | undefined;
};

export const GetSubscriptionsResponse$zodSchema: z.ZodType<
  GetSubscriptionsResponse
> = z.object({
  ContentType: z.string(),
  RawResponse: z.custom<Response>(x => x instanceof Response),
  StatusCode: z.int(),
  SubscriptionsSubscriptionList: z.lazy(() =>
    SubscriptionsSubscriptionList$zodSchema
  ).optional(),
  error: ErrorT$zodSchema.optional(),
});
