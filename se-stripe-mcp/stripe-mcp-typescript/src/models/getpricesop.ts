/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { ClosedEnum } from "../types/enums.js";
import { ErrorT, ErrorT$zodSchema } from "./error.js";
import { Price, Price$zodSchema } from "./price.js";

export type GetPricesRangeQuerySpecs = {
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export const GetPricesRangeQuerySpecs$zodSchema: z.ZodType<
  GetPricesRangeQuerySpecs
> = z.object({
  gt: z.int().optional(),
  gte: z.int().optional(),
  lt: z.int().optional(),
  lte: z.int().optional(),
});

/**
 * A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
 */
export type GetPricesCreated = GetPricesRangeQuerySpecs | number;

export const GetPricesCreated$zodSchema: z.ZodType<GetPricesCreated> = z.union([
  z.lazy(() => GetPricesRangeQuerySpecs$zodSchema),
  z.int(),
]).describe(
  "A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.",
);

export const GetPricesInterval = {
  Day: "day",
  Month: "month",
  Week: "week",
  Year: "year",
} as const;
export type GetPricesInterval = ClosedEnum<typeof GetPricesInterval>;

export const GetPricesInterval$zodSchema = z.enum([
  "day",
  "month",
  "week",
  "year",
]);

export const GetPricesUsageType = {
  Licensed: "licensed",
  Metered: "metered",
} as const;
export type GetPricesUsageType = ClosedEnum<typeof GetPricesUsageType>;

export const GetPricesUsageType$zodSchema = z.enum([
  "licensed",
  "metered",
]);

/**
 * Only return prices with these recurring fields.
 */
export type AllPricesRecurringParams = {
  interval?: GetPricesInterval | undefined;
  meter?: string | undefined;
  usage_type?: GetPricesUsageType | undefined;
};

export const AllPricesRecurringParams$zodSchema: z.ZodType<
  AllPricesRecurringParams
> = z.object({
  interval: GetPricesInterval$zodSchema.optional(),
  meter: z.string().optional(),
  usage_type: GetPricesUsageType$zodSchema.optional(),
}).describe("Only return prices with these recurring fields.");

/**
 * Only return prices of type `recurring` or `one_time`.
 */
export const GetPricesType = {
  OneTime: "one_time",
  Recurring: "recurring",
} as const;
/**
 * Only return prices of type `recurring` or `one_time`.
 */
export type GetPricesType = ClosedEnum<typeof GetPricesType>;

export const GetPricesType$zodSchema = z.enum([
  "one_time",
  "recurring",
]).describe("Only return prices of type `recurring` or `one_time`.");

export type GetPricesRequest = {
  active?: boolean | undefined;
  created?: GetPricesRangeQuerySpecs | number | undefined;
  currency?: string | undefined;
  ending_before?: string | undefined;
  expand?: Array<string> | undefined;
  limit?: number | undefined;
  lookup_keys?: Array<string> | undefined;
  product?: string | undefined;
  recurring?: AllPricesRecurringParams | undefined;
  starting_after?: string | undefined;
  type?: GetPricesType | undefined;
};

export const GetPricesRequest$zodSchema: z.ZodType<GetPricesRequest> = z.object(
  {
    active: z.boolean().describe(
      "Only return prices that are active or inactive (e.g., pass `false` to list all inactive prices).",
    ).optional(),
    created: z.union([
      z.lazy(() => GetPricesRangeQuerySpecs$zodSchema),
      z.int(),
    ]).optional(),
    currency: z.string().describe("Only return prices for the given currency.")
      .optional(),
    ending_before: z.string().describe(
      "A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.",
    ).optional(),
    expand: z.array(z.string()).describe(
      "Specifies which fields in the response should be expanded.",
    ).optional(),
    limit: z.int().describe(
      "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.",
    ).optional(),
    lookup_keys: z.array(z.string()).describe(
      "Only return the price with these lookup_keys, if any exist. You can specify up to 10 lookup_keys.",
    ).optional(),
    product: z.string().describe("Only return prices for the given product.")
      .optional(),
    recurring: z.lazy(() => AllPricesRecurringParams$zodSchema).optional(),
    starting_after: z.string().describe(
      "A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.",
    ).optional(),
    type: GetPricesType$zodSchema.optional(),
  },
);

/**
 * Successful response.
 */
export type PriceList = { data: Array<Price>; has_more: boolean; url: string };

export const PriceList$zodSchema: z.ZodType<PriceList> = z.object({
  data: z.array(Price$zodSchema),
  has_more: z.boolean(),
  url: z.string(),
}).describe("Successful response.");

export type GetPricesResponse = {
  ContentType: string;
  StatusCode: number;
  RawResponse: Response;
  PriceList?: PriceList | undefined;
  error?: ErrorT | undefined;
};

export const GetPricesResponse$zodSchema: z.ZodType<GetPricesResponse> = z
  .object({
    ContentType: z.string(),
    PriceList: z.lazy(() => PriceList$zodSchema).optional(),
    RawResponse: z.custom<Response>(x => x instanceof Response),
    StatusCode: z.int(),
    error: ErrorT$zodSchema.optional(),
  });
